
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>UFO Crop Circles Map</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Roboto', sans-serif; 
      background: #000;
      color: #202124; 
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: pan-x pan-y;
    }
    
    #canvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      cursor: grab;
      touch-action: none;
    }
    #canvas:active { cursor: grabbing; }
    
    /* Sidebar */
    #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      max-width: 380px;
      height: 100vh;
      background: #fff;
      box-shadow: 2px 0 8px rgba(0,0,0,0.1);
      overflow-y: auto;
      z-index: 900;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #sidebar.open { transform: translateX(0); }
    
    #sidebar::-webkit-scrollbar { width: 6px; }
    #sidebar::-webkit-scrollbar-track { background: transparent; }
    #sidebar::-webkit-scrollbar-thumb { 
      background: #dadce0; 
      border-radius: 3px; 
    }
    
    .sidebar-header {
      padding: 20px 16px 16px;
      border-bottom: 1px solid #e8eaed;
    }
    
    .sidebar-title {
      font-size: 22px;
      font-weight: 400;
      color: #202124;
      margin-bottom: 4px;
    }
    
    .sidebar-subtitle {
      font-size: 14px;
      color: #5f6368;
      line-height: 1.4;
    }
    
    .location-list { padding: 8px 0; }
    
    .location-card {
      padding: 16px;
      cursor: pointer;
      transition: background 0.2s;
      border-bottom: 1px solid #e8eaed;
      display: flex;
      align-items: center;
      gap: 0;
    }
    
    .location-card:hover { background: #f1f3f4; }
    .location-card:active { background: #e8eaed; }
    .location-card.active { background: #e8f0fe; }
    
    .location-info { flex: 1; min-width: 0; }
    
    .location-name {
      font-size: 16px;
      font-weight: 500;
      color: #202124;
      margin-bottom: 4px;
    }
    
    .location-details {
      font-size: 14px;
      color: #5f6368;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .location-type {
      display: inline-block;
      padding: 2px 8px;
      background: #e8f0fe;
      color: #1967d2;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }
    
    .location-count {
      font-size: 20px;
      font-weight: 500;
      color: #1a73e8;
      text-align: right;
    }
    
    /* Menu Button */
    #menu-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 48px;
      height: 48px;
      background: #fff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: all 0.2s;
    }
    
    #menu-btn:hover {
      background: #f8f9fa;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #menu-btn:active {
      transform: scale(0.95);
    }
    
    .menu-icon {
      width: 18px;
      height: 2px;
      background: #5f6368;
      position: relative;
      transition: 0.3s;
    }
    
    .menu-icon::before,
    .menu-icon::after {
      content: '';
      position: absolute;
      left: 0;
      width: 18px;
      height: 2px;
      background: #5f6368;
      transition: 0.3s;
    }
    .menu-icon::before { top: -6px; }
    .menu-icon::after { top: 6px; }
    
    /* Controls */
    #controls {
      position: fixed;
      bottom: 20px;
      right: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
    }
    
    .control-btn {
      width: 48px;
      height: 48px;
      background: #fff;
      border: none;
      border-radius: 50%;
      color: #5f6368;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .control-btn:hover {
      background: #f8f9fa;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .control-btn:active {
      transform: scale(0.95);
    }

    /* ‚Üì‚Üì‚Üì Ïó¨Í∏∞ ÏïÑÎûòÏóê Ï∂îÍ∞Ä! ‚Üì‚Üì‚Üì */
#sightings-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  background: #1a73e8;
  color: #fff;
  text-decoration: none;
  border-radius: 24px;
  font-size: 14px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  transition: all 0.2s;
  z-index: 1000;
}

#sightings-btn:hover {
  background: #1557b0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transform: translateY(-2px);
}

#sightings-btn:active {
  transform: translateY(0);
}

@media (max-width: 768px) {
  #sightings-btn {
    top: 16px;
    right: 16px;
    padding: 10px 16px;
    font-size: 13px;
  }
}

    

    
    #crop-image {
      width: 100%;
      height: 200px;
      background: #f5f5f5;
      border-radius: 8px;
      margin: 10px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    #crop-image canvas {
      border-radius: 8px;
    }
    /* Popup */
    #popup {
      position: fixed;
      background: #fff;
      border-radius: 12px;
      padding: 16px;
      min-width: 280px;
      max-width: 90%;
      z-index: 2000;
      display: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.2);
    }
    
    #popup.show {
      display: block;
      animation: popupIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes popupIn {
      from { opacity: 0; transform: translateY(20px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    #popup-title {
      font-size: 20px;
      font-weight: 400;
      color: #202124;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .popup-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #e8eaed;
    }
    
    .popup-row:last-child { border-bottom: none; }
    
    .popup-label {
      color: #5f6368;
      font-size: 13px;
    }
    
    .popup-value {
      color: #202124;
      font-size: 15px;
      font-weight: 500;
    }
    
    #close-popup {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 28px;
      height: 28px;
      border: none;
      background: none;
      color: #5f6368;
      border-radius: 50%;
      cursor: pointer;
      font-size: 22px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #close-popup:hover {
      background: #f1f3f4;
      color: #202124;
    }
    
    /* Loading */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }
    
    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(255,255,255,0.2);
      border-top-color: #1a73e8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }
    
    .loading-text {
      margin-top: 20px;
      color: #fff;
      font-size: 16px;
    }
    
    /* Overlay */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 800;
      display: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #overlay.show {
      display: block;
      opacity: 1;
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      #sidebar { max-width: 100%; }
      #controls { bottom: 20px; right: 12px; }
      .control-btn { width: 44px; height: 44px; }
      #popup { min-width: 200px; padding: 14px; }
      #menu-btn { top: 16px; left: 16px; width: 44px; height: 44px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading map...</div>
  </div>
  
  <button id="menu-btn">
    <div class="menu-icon"></div>
  </button>
  
  <div id="overlay"></div>
  
  <div id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">UFO Sighting Locations</div>
      <div class="sidebar-subtitle">Select a location to view details</div>
    </div>
    <div class="location-list" id="location-list"></div>
  </div>
  
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <button class="control-btn" id="zoom-in">+</button>
    <button class="control-btn" id="zoom-out">‚àí</button>
    <button class="control-btn" id="reset">‚ü≤</button>
  </div>

<a href="https://chaelinnnnn.github.io/ufo-sightings/" 
   id="sightings-btn" 
   class="sightings-link">
  UFO Sightings ‚ûú
</a>

  
  <div id="popup">
    <button id="close-popup">√ó</button>
    <div id="popup-title"></div>
    <div id="crop-image"></div>
    <div id="popup-content"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // IMPORTANT: Original coordinate system (5120 x 2008)
    // We'll adjust these to match actual image dimensions on load
    let COORD_W = 5120;
    let COORD_H = 2008;
    
    // Original coordinates - will be scaled on image load
    const locations = [{'x': 597, 'y': 789, 'name': 'New York', 'sightings': 4523, 'type': 'Circle', 'icon': '‚≠ï'}, {'x': 524, 'y': 1618, 'name': 'Pennsylvania', 'sightings': 3987, 'type': 'Disk', 'icon': 'üõ∏'}, {'x': 1121, 'y': 1618, 'name': 'N. Carolina', 'sightings': 3234, 'type': 'Light', 'icon': 'üîÜ'}, {'x': 1650, 'y': 320, 'name': 'Florida', 'sightings': 5621, 'type': 'Light', 'icon': 'üîÜ'}, {'x': 1615, 'y': 1145, 'name': 'Michigan', 'sightings': 3623, 'type': 'Disk', 'icon': 'üõ∏'}, {'x': 2314, 'y': 1691, 'name': 'Arizona', 'sightings': 4234, 'type': 'Light', 'icon': 'üîÜ'}, {'x': 3311, 'y': 527, 'name': 'Ohio', 'sightings': 3756, 'type': 'Circle', 'icon': '‚≠ï'}, {'x': 3602, 'y': 1473, 'name': 'California', 'sightings': 12024, 'type': 'Light', 'icon': 'üîÜ'}, {'x': 4861, 'y': 905, 'name': 'Washington', 'sightings': 5894, 'type': 'Disk', 'icon': 'üõ∏'}, {'x': 4497, 'y': 1851, 'name': 'Texas', 'sightings': 4987, 'type': 'Light', 'icon': 'üîÜ'}];
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const popup = document.getElementById('popup');
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('overlay');
    const menuBtn = document.getElementById('menu-btn');
    
    let image = new Image();
    let offsetX = 0, offsetY = 0, scale = 1, minScale = 1;
    let isDragging = false, dragStartX = 0, dragStartY = 0;
    let lastOffsetX = 0, lastOffsetY = 0;
    let selectedLocation = null, hoveredMarker = null;
    
    // Touch support
    let touchStartX = 0, touchStartY = 0;
    let lastTouchDistance = 0;
    let isTouching = false;
    
    image.onload = () => {
      // Adjust coordinate system and locations to match actual image size
      const scaleFactor = image.width / COORD_W;
      console.log('Image loaded:', image.width, 'x', image.height);
      console.log('Scale factor:', scaleFactor, '(from', COORD_W, 'x', COORD_H, 'to', image.width, 'x', image.height + ')');
      
      // Update coordinate system to match actual image
      COORD_W = image.width;
      COORD_H = image.height;
      
      // Scale all location coordinates to match new coordinate system
      locations.forEach(loc => {
        loc.x *= scaleFactor;
        loc.y *= scaleFactor;
      });
      
      document.getElementById('loading').style.display = 'none';
      resizeCanvas();
      initSidebar();
    };
    image.src = 'https://i.imgur.com/cLt2ay2.jpeg'
    
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      
      // Set display size
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      
      // Set actual canvas size (accounting for device pixel ratio)
      canvas.width = displayWidth * dpr;
      canvas.height = displayHeight * dpr;
      
      // Set CSS display size
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';
      
      // Scale the context to match device pixel ratio
      ctx.scale(dpr, dpr);
      
      // Calculate scale to fill the entire screen (cover mode)
      const scaleX = displayWidth / COORD_W;
      const scaleY = displayHeight / COORD_H;
      minScale = Math.max(scaleX, scaleY);
      scale = minScale;
      
      // Center the map
      const displayW = COORD_W * scale;
      const displayH = COORD_H * scale;
      
      offsetX = (displayWidth - displayW) / 2;
      offsetY = (displayHeight - displayH) / 2;
      
      draw();
    }
    
    function toDisplayCoords(origX, origY) {
      return {
        x: offsetX + origX * scale,
        y: offsetY + origY * scale
      };
    }
    
    function constrainView() {
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      const displayW = COORD_W * scale;
      const displayH = COORD_H * scale;
      
      if (displayW > displayWidth) {
        const maxOffsetX = 0;
        const minOffsetX = displayWidth - displayW;
        offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
      } else {
        offsetX = (displayWidth - displayW) / 2;
      }
      
      if (displayH > displayHeight) {
        const maxOffsetY = 0;
        const minOffsetY = displayHeight - displayH;
        offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
      } else {
        offsetY = (displayHeight - displayH) / 2;
      }
    }
    
    function draw() {
      constrainView();
      
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      
      ctx.clearRect(0, 0, displayWidth, displayHeight);
      
      // High quality rendering - use actual image dimensions
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // COORD_W/COORD_H now match image.width/image.height, so no scaling needed
      const displayW = COORD_W * scale;
      const displayH = COORD_H * scale;
      ctx.drawImage(image, offsetX, offsetY, displayW, displayH);
      
      locations.forEach((loc, i) => {
        const pos = toDisplayCoords(loc.x, loc.y);
        const isSelected = selectedLocation === i;
        const isHovered = hoveredMarker === i;
        
        // Text only - clean and simple
        const text = loc.name;
        const fontSize = 14;
        const fontWeight = isSelected || isHovered ? '700' : '500';
        ctx.font = `${fontWeight} ${fontSize}px Roboto`;
        
        // Text shadow for readability
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        
        // Text color
        ctx.fillStyle = isSelected || isHovered ? '#00ff88' : '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, pos.x, pos.y);
        
        // Reset shadow
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      });
    }
    
    function initSidebar() {
      const list = document.getElementById('location-list');
      locations.forEach((loc, i) => {
        const div = document.createElement('div');
        div.className = 'location-card';
        div.innerHTML = `
          <div class="location-info">
            <div class="location-name">${loc.name}</div>
            <div class="location-details">
              <span>${loc.sightings.toLocaleString()} sightings</span>
              <span class="location-type">${loc.type}</span>
            </div>
          </div>
          <div class="location-count">${loc.sightings.toLocaleString()}</div>
        `;
        div.onclick = () => {
          selectLocation(i);
          if (window.innerWidth < 768) {
            closeSidebar();
          }
        };
        list.appendChild(div);
      });
    }
    
    function selectLocation(index) {
      selectedLocation = index;
      const loc = locations[index];
      
      document.querySelectorAll('.location-card').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      
      // Show popup immediately without zooming
      draw(); // Redraw to show selection highlight
      showPopup(index);
    }
    
    function animateZoom(targetX, targetY, targetScale, callback) {
      const startX = offsetX, startY = offsetY, startScale = scale;
      const duration = 700, startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        
        offsetX = startX + (targetX - startX) * eased;
        offsetY = startY + (targetY - startY) * eased;
        scale = startScale + (targetScale - startScale) * eased;
        
        draw();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else if (callback) {
          callback();
        }
      }
      
      animate();
    }
    
    // State code mapping
    const stateCodeMap = {
      'New York': 'NY',
      'Pennsylvania': 'PA',
      'N. Carolina': 'NC',
      'Florida': 'FL',
      'Michigan': 'MI',
      'Arizona': 'AZ',
      'Ohio': 'OH',
      'California': 'CA',
      'Washington': 'WA',
      'Texas': 'TX'
    };

    const stateData3D = {
      CA: { scale: 1.50 },
      FL: { scale: 0.91 },
      TX: { scale: 0.83 },
      AZ: { scale: 0.74 },
      NC: { scale: 0.60 },
      WA: { scale: 8.46 },
      NY: { scale: 0.78 },
      PA: { scale: 6.39 },
      OH: { scale: 0.68 },
      MI: { scale: 5.94 }
    };

    function createMetal(color) {
      return new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.95,
        roughness: 0.1,
        side: THREE.DoubleSide
      });
    }

    function createSmoothRibbon(s, angle) {
      const ribbonGroup = new THREE.Group();
      const segments = 100;
      const ribbonRadius = 0.15 * s;
      const heightRange = 4.5 * s;
      const maxRadius = 2.3 * s;
      
      const points = [];
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const y = (t - 0.5) * heightRange;
        const radius = Math.sin(t * Math.PI) * maxRadius;
        const twist = t * Math.PI * 1.5;
        
        points.push(new THREE.Vector3(
          Math.cos(twist) * radius,
          y,
          Math.sin(twist) * radius
        ));
      }
      
      const curve = new THREE.CatmullRomCurve3(points);
      const tubeGeometry = new THREE.TubeGeometry(curve, 100, ribbonRadius, 16, false);
      const mesh = new THREE.Mesh(tubeGeometry, createMetal(0x888888));
      mesh.castShadow = true;
      ribbonGroup.add(mesh);
      
      ribbonGroup.rotation.y = angle;
      return ribbonGroup;
    }

    function createCurvedRibbon(s, angle, lift) {
      const segments = 40;
      const length = 0.25 * s;
      const baseWidth = 0.03 * s;
      const thickness = 0.004 * s;
      
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];
      
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const dist = length * t;
        
        const centerX = Math.cos(angle) * dist;
        const centerZ = Math.sin(angle) * dist;
        const centerY = lift * dist * Math.sin(t * Math.PI * 0.6);
        
        const wave = Math.sin(t * Math.PI * 3) * 0.3 + 0.7;
        const currentWidth = baseWidth * wave;
        
        const perpX = -Math.sin(angle);
        const perpZ = Math.cos(angle);
        
        const leftX = centerX + perpX * currentWidth;
        const leftZ = centerZ + perpZ * currentWidth;
        const leftY = centerY;
        
        const rightX = centerX - perpX * currentWidth;
        const rightZ = centerZ - perpZ * currentWidth;
        const rightY = centerY;
        
        vertices.push(leftX, leftY + thickness, leftZ);
        vertices.push(rightX, rightY + thickness, rightZ);
        vertices.push(leftX, leftY - thickness, leftZ);
        vertices.push(rightX, rightY - thickness, rightZ);
      }
      
      for (let i = 0; i < segments; i++) {
        const base = i * 4;
        const next = (i + 1) * 4;
        
        indices.push(base, next, base + 1);
        indices.push(next, next + 1, base + 1);
        
        indices.push(base + 2, base + 3, next + 2);
        indices.push(next + 2, base + 3, next + 3);
        
        indices.push(base, base + 2, next);
        indices.push(next, base + 2, next + 2);
        
        indices.push(base + 1, next + 1, base + 3);
        indices.push(next + 1, next + 3, base + 3);
      }
      
      const posArray = new Float32Array(vertices);
      geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      
      const mesh = new THREE.Mesh(geometry, createMetal(0x777777));
      mesh.castShadow = true;
      
      return mesh;
    }

    function makeCA(group, s) {
      for (let i = 0; i < 6; i++) {
        group.add(createSmoothRibbon(s, (i / 6) * Math.PI * 2));
      }
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 13.5, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -3.6;
      group.add(axis);
    }

    function makeFL(group, s) {
      for (let i = 0; i < 5; i++) {
        group.add(createSmoothRibbon(s, (i / 5) * Math.PI * 2));
      }
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 6.5, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -1.3;
      group.add(axis);
    }

    function makeTX(group, s) {
      for (let i = 0; i < 4; i++) {
        group.add(createSmoothRibbon(s, (i / 4) * Math.PI * 2));
      }
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 5.5, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -1.0;
      group.add(axis);
    }

    function makeAZ(group, s) {
      for (let i = 0; i < 4; i++) {
        group.add(createSmoothRibbon(s, (i / 4) * Math.PI * 2));
      }
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 4.8, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -0.8;
      group.add(axis);
    }

    function makeNC(group, s) {
      for (let i = 0; i < 3; i++) {
        group.add(createSmoothRibbon(s, (i / 3) * Math.PI * 2));
      }
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 3.8, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -0.6;
      group.add(axis);
    }

    function makeNY(group, s) {
      const rotatedGroup = new THREE.Group();
      rotatedGroup.rotation.z = Math.PI / 2;
      const largeRings = [
        { radius: 2.8, thickness: 0.12, rotX: Math.PI / 2, rotY: 0, rotZ: 0 },
        { radius: 2.5, thickness: 0.11, rotX: Math.PI / 3, rotY: Math.PI / 6, rotZ: 0 }
      ];
      largeRings.forEach(ring => {
        const geo = new THREE.TorusGeometry(ring.radius * s, ring.thickness * s, 16, 64);
        const mesh = new THREE.Mesh(geo, createMetal(0x1a1a1a));
        mesh.rotation.set(ring.rotX, ring.rotY, ring.rotZ);
        mesh.castShadow = true;
        rotatedGroup.add(mesh);
      });
      const mediumCurves = [
        { radius: 1.8, thickness: 0.09, rotX: Math.PI / 4, rotY: Math.PI / 3, rotZ: 0 },
        { radius: 1.6, thickness: 0.08, rotX: Math.PI / 1.8, rotY: -Math.PI / 4, rotZ: Math.PI / 6 },
        { radius: 1.9, thickness: 0.085, rotX: Math.PI / 2.2, rotY: Math.PI / 2.5, rotZ: -Math.PI / 8 }
      ];
      mediumCurves.forEach(curve => {
        const geo = new THREE.TorusGeometry(curve.radius * s, curve.thickness * s, 14, 56);
        const mesh = new THREE.Mesh(geo, createMetal(0x252525));
        mesh.rotation.set(curve.rotX, curve.rotY, curve.rotZ);
        mesh.castShadow = true;
        rotatedGroup.add(mesh);
      });
      const smallCurves = [
        { radius: 0.9, thickness: 0.06, rotX: Math.PI / 3.5, rotY: Math.PI / 4.5, rotZ: Math.PI / 10 },
        { radius: 1.0, thickness: 0.065, rotX: Math.PI / 2.8, rotY: -Math.PI / 3.8, rotZ: -Math.PI / 12 }
      ];
      smallCurves.forEach(curve => {
        const geo = new THREE.TorusGeometry(curve.radius * s, curve.thickness * s, 12, 48);
        const mesh = new THREE.Mesh(geo, createMetal(0x303030));
        mesh.rotation.set(curve.rotX, curve.rotY, curve.rotZ);
        mesh.castShadow = true;
        rotatedGroup.add(mesh);
      });
      group.add(rotatedGroup);
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 5.0, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -1.5;
      group.add(axis);
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.15 * s, 32, 32), createMetal(0x888888));
      sphere.castShadow = true;
      sphere.position.y = 1.0;
      group.add(sphere);
    }

    function makeOH(group, s) {
      const rotatedGroup = new THREE.Group();
      rotatedGroup.rotation.z = Math.PI / 2;
      const largeMesh = new THREE.Mesh(new THREE.TorusGeometry(2.6 * s, 0.12 * s, 16, 64), createMetal(0x1a1a1a));
      largeMesh.rotation.x = Math.PI / 2;
      largeMesh.castShadow = true;
      rotatedGroup.add(largeMesh);
      const mediumCurves = [
        { radius: 1.8, thickness: 0.09, rotX: Math.PI / 4, rotY: Math.PI / 3, rotZ: 0 },
        { radius: 1.6, thickness: 0.08, rotX: Math.PI / 1.8, rotY: -Math.PI / 4, rotZ: Math.PI / 6 }
      ];
      mediumCurves.forEach(curve => {
        const mesh = new THREE.Mesh(new THREE.TorusGeometry(curve.radius * s, curve.thickness * s, 14, 56), createMetal(0x252525));
        mesh.rotation.set(curve.rotX, curve.rotY, curve.rotZ);
        mesh.castShadow = true;
        rotatedGroup.add(mesh);
      });
      const smallMesh = new THREE.Mesh(new THREE.TorusGeometry(0.9 * s, 0.06 * s, 12, 48), createMetal(0x303030));
      smallMesh.rotation.set(Math.PI / 3.5, Math.PI / 4.5, Math.PI / 10);
      smallMesh.castShadow = true;
      rotatedGroup.add(smallMesh);
      group.add(rotatedGroup);
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 4.3, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -1.3;
      group.add(axis);
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.14 * s, 32, 32), createMetal(0x888888));
      sphere.castShadow = true;
      sphere.position.y = 0.9;
      group.add(sphere);
    }

    function makeWA(group, s) {
      const ribbons = [
        { angle: 0, lift: 0.9 },
        { angle: Math.PI * 0.5, lift: 1.0 },
        { angle: Math.PI, lift: 0.85 },
        { angle: Math.PI * 1.5, lift: 0.95 }
      ];
      const lowerGroup1 = new THREE.Group();
      ribbons.forEach(r => lowerGroup1.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup1.position.y = -0.25 * s;
      group.add(lowerGroup1);
      const upperGroup1 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup1.add(ribbon);
      });
      upperGroup1.position.y = 0.25 * s;
      group.add(upperGroup1);
      const lowerGroup2 = new THREE.Group();
      ribbons.forEach(r => lowerGroup2.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup2.position.y = -0.25 * s;
      lowerGroup2.rotation.y = Math.PI / 4;
      group.add(lowerGroup2);
      const upperGroup2 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup2.add(ribbon);
      });
      upperGroup2.position.y = 0.25 * s;
      upperGroup2.rotation.y = Math.PI / 4;
      group.add(upperGroup2);
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 6.5, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -1.2;
      group.add(axis);
    }

    function makePA(group, s) {
      const ribbons = [
        { angle: 0, lift: 0.9 },
        { angle: 2.09, lift: 1.0 },
        { angle: 4.19, lift: 0.95 }
      ];
      const lowerGroup1 = new THREE.Group();
      ribbons.forEach(r => lowerGroup1.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup1.position.y = -0.25 * s;
      group.add(lowerGroup1);
      const upperGroup1 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup1.add(ribbon);
      });
      upperGroup1.position.y = 0.25 * s;
      group.add(upperGroup1);
      const lowerGroup2 = new THREE.Group();
      ribbons.forEach(r => lowerGroup2.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup2.position.y = -0.25 * s;
      lowerGroup2.rotation.y = Math.PI / 4;
      group.add(lowerGroup2);
      const upperGroup2 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup2.add(ribbon);
      });
      upperGroup2.position.y = 0.25 * s;
      upperGroup2.rotation.y = Math.PI / 4;
      group.add(upperGroup2);
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 4.5, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -0.7;
      group.add(axis);
    }

    function makeMI(group, s) {
      const ribbons = [
        { angle: 0, lift: 0.9 },
        { angle: 2.09, lift: 0.95 },
        { angle: 4.19, lift: 0.88 }
      ];
      const lowerGroup1 = new THREE.Group();
      ribbons.forEach(r => lowerGroup1.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup1.position.y = -0.25 * s;
      group.add(lowerGroup1);
      const upperGroup1 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup1.add(ribbon);
      });
      upperGroup1.position.y = 0.25 * s;
      group.add(upperGroup1);
      const lowerGroup2 = new THREE.Group();
      ribbons.forEach(r => lowerGroup2.add(createCurvedRibbon(s, r.angle, r.lift)));
      lowerGroup2.position.y = -0.25 * s;
      lowerGroup2.rotation.y = Math.PI / 4;
      group.add(lowerGroup2);
      const upperGroup2 = new THREE.Group();
      ribbons.forEach(r => {
        const ribbon = createCurvedRibbon(s, r.angle, r.lift);
        ribbon.scale.y = -1;
        upperGroup2.add(ribbon);
      });
      upperGroup2.position.y = 0.25 * s;
      upperGroup2.rotation.y = Math.PI / 4;
      group.add(upperGroup2);
      const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 4.2, 16), createMetal(0x666666));
      axis.castShadow = true;
      axis.position.y = -0.7;
      group.add(axis);
    }

    let popup3DScene = null;
    let popup3DCamera = null;
    let popup3DRenderer = null;
    let popup3DSculpture = null;
    let popup3DAnimationId = null;

    function createPopup3D(locationName) {
      const container = document.getElementById('crop-image');
      container.innerHTML = '';
      
      // Stop previous animation
      if (popup3DAnimationId) {
        cancelAnimationFrame(popup3DAnimationId);
      }
      
      const width = container.offsetWidth || 280;
      const height = 200;
      
      // Get state code
      const stateCode = stateCodeMap[locationName];
      if (!stateCode) return;
      
      // Create Three.js scene
      popup3DScene = new THREE.Scene();
      popup3DScene.background = new THREE.Color(0xf5f5f5);
      
      popup3DCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
      popup3DCamera.position.set(0, 2, 8);
      popup3DCamera.lookAt(0, 0, 0);
      
      popup3DRenderer = new THREE.WebGLRenderer({ antialias: true });
      popup3DRenderer.setSize(width, height);
      popup3DRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      popup3DRenderer.shadowMap.enabled = false;
      container.appendChild(popup3DRenderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      popup3DScene.add(ambientLight);
      
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
      keyLight.position.set(10, 15, 8);
      popup3DScene.add(keyLight);
      
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
      fillLight.position.set(-8, 8, -8);
      popup3DScene.add(fillLight);
      
      // Create sculpture
      popup3DSculpture = new THREE.Group();
      const s = stateData3D[stateCode].scale;
      
      if (stateCode === 'CA') makeCA(popup3DSculpture, s);
      else if (stateCode === 'FL') makeFL(popup3DSculpture, s);
      else if (stateCode === 'TX') makeTX(popup3DSculpture, s);
      else if (stateCode === 'AZ') makeAZ(popup3DSculpture, s);
      else if (stateCode === 'NC') makeNC(popup3DSculpture, s);
      else if (stateCode === 'NY') makeNY(popup3DSculpture, s);
      else if (stateCode === 'OH') makeOH(popup3DSculpture, s);
      else if (stateCode === 'WA') makeWA(popup3DSculpture, s);
      else if (stateCode === 'PA') makePA(popup3DSculpture, s);
      else if (stateCode === 'MI') makeMI(popup3DSculpture, s);
      
      // Scale all sculptures to 0.85
      popup3DSculpture.scale.set(0.85, 0.85, 0.85);
      
      popup3DScene.add(popup3DSculpture);
      
      // Animation loop
      function animate3D() {
        popup3DAnimationId = requestAnimationFrame(animate3D);
        
        if (popup3DSculpture) {
          popup3DSculpture.rotation.y += 0.005;
        }
        
        popup3DRenderer.render(popup3DScene, popup3DCamera);
      }
      
      animate3D();
    }
    
    function showPopup(index) {
      const loc = locations[index];
      const pos = toDisplayCoords(loc.x, loc.y);
      
      popup.querySelector('#popup-title').innerHTML = `${loc.name}`;
      
      // Create 3D crop circle
      createPopup3D(loc.name);
      
      popup.querySelector('#popup-content').innerHTML = `
        <div class="popup-row">
          <span class="popup-label">Total Sightings</span>
          <span class="popup-value">${loc.sightings.toLocaleString()}</span>
        </div>
        <div class="popup-row">
          <span class="popup-label">UFO Type</span>
          <span class="popup-value">${loc.type}</span>
        </div>
      `;
      
      // Smart popup positioning - avoid covering the clicked location
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      const popupWidth = 312; // min-width 280px + padding
      const popupHeight = 360; // estimated with 200px 3D image
      const margin = 20;
      const offset = 50; // offset from click point
      
      let left, top;
      
      // Horizontal positioning: place on the side with more space
      if (pos.x < displayWidth / 2) {
        // Click is on left side - place popup on right
        left = Math.min(pos.x + offset, displayWidth - popupWidth - margin);
      } else {
        // Click is on right side - place popup on left
        left = Math.max(pos.x - popupWidth - offset, margin);
      }
      
      // Vertical positioning: place on the side with more space
      if (pos.y < displayHeight / 2) {
        // Click is on top half - place popup below
        top = Math.min(pos.y + offset, displayHeight - popupHeight - margin);
      } else {
        // Click is on bottom half - place popup above
        top = Math.max(pos.y - popupHeight - offset, margin);
      }
      
      // Ensure popup stays within screen bounds
      left = Math.max(margin, Math.min(left, displayWidth - popupWidth - margin));
      top = Math.max(margin, Math.min(top, displayHeight - popupHeight - margin));
      
      popup.style.left = left + 'px';
      popup.style.top = top + 'px';
      popup.classList.add('show');
    } 
    function openSidebar() {
      sidebar.classList.add('open');
      overlay.classList.add('show');
    }
    
    function closeSidebar() {
      sidebar.classList.remove('open');
      overlay.classList.remove('show');
    }
    
    menuBtn.onclick = () => {
      if (sidebar.classList.contains('open')) {
        closeSidebar();
      } else {
        openSidebar();
      }
    };
    
    overlay.onclick = closeSidebar;
    
    document.getElementById('close-popup').onclick = () => {
      popup.classList.remove('show');
      selectedLocation = null;
      document.querySelectorAll('.location-card').forEach(el => el.classList.remove('active'));
      draw();
    };
    
    // Mouse events
    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      lastOffsetX = offsetX;
      lastOffsetY = offsetY;
    });
    
    canvas.addEventListener('mousemove', e => {
      if (isDragging) {
        offsetX = lastOffsetX + (e.clientX - dragStartX);
        offsetY = lastOffsetY + (e.clientY - dragStartY);
        draw();
      } else {
        updateHoveredMarker(e.clientX, e.clientY);
      }
    });
    
    canvas.addEventListener('mouseup', e => {
      if (isDragging) {
        const dx = Math.abs(e.clientX - dragStartX);
        const dy = Math.abs(e.clientY - dragStartY);
        if (dx < 5 && dy < 5 && hoveredMarker >= 0) {
          selectLocation(hoveredMarker);
        }
      }
      isDragging = false;
    });
    
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const oldScale = scale;
      scale *= e.deltaY < 0 ? 1.12 : 0.88;
      scale = Math.max(minScale, Math.min(15, scale));
      
      offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
      offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
      
      draw();
    }, { passive: false });
    
    // Touch events
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      
      if (e.touches.length === 1) {
        isTouching = true;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        lastOffsetX = offsetX;
        lastOffsetY = offsetY;
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      
      if (e.touches.length === 1 && isTouching) {
        const touch = e.touches[0];
        offsetX = lastOffsetX + (touch.clientX - touchStartX);
        offsetY = lastOffsetY + (touch.clientY - touchStartY);
        draw();
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (lastTouchDistance > 0) {
          const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          
          const oldScale = scale;
          scale *= distance / lastTouchDistance;
          scale = Math.max(minScale, Math.min(15, scale));
          
          const rect = canvas.getBoundingClientRect();
          const mouseX = centerX - rect.left;
          const mouseY = centerY - rect.top;
          
          offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
          offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
          
          draw();
        }
        
        lastTouchDistance = distance;
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      
      if (e.touches.length === 0) {
        if (isTouching) {
          const touch = e.changedTouches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          
          if (dx < 10 && dy < 10) {
            updateHoveredMarker(touch.clientX, touch.clientY);
            if (hoveredMarker >= 0) {
              selectLocation(hoveredMarker);
            }
          }
        }
        isTouching = false;
        lastTouchDistance = 0;
      }
    }, { passive: false });
    
    function updateHoveredMarker(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;
      
      let found = -1;
      locations.forEach((loc, i) => {
        const pos = toDisplayCoords(loc.x, loc.y);
        ctx.font = '500 14px Roboto';
        const textWidth = ctx.measureText(loc.name).width;
        const textHeight = 14;
        
        // Slightly larger hit area for easier clicking
        const hitPadding = 8;
        if (mouseX >= pos.x - textWidth/2 - hitPadding && 
            mouseX <= pos.x + textWidth/2 + hitPadding &&
            mouseY >= pos.y - textHeight/2 - hitPadding && 
            mouseY <= pos.y + textHeight/2 + hitPadding) {
          found = i;
        }
      });
      
      if (found !== hoveredMarker) {
        hoveredMarker = found;
        canvas.style.cursor = found >= 0 ? 'pointer' : 'grab';
        draw();
      }
    }
    
    // Control buttons
    document.getElementById('zoom-in').onclick = () => {
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      const cx = displayWidth / 2;
      const cy = displayHeight / 2;
      const old = scale;
      scale = Math.min(15, scale * 1.3);
      offsetX = cx - (cx - offsetX) * (scale / old);
      offsetY = cy - (cy - offsetY) * (scale / old);
      draw();
    };
    
    document.getElementById('zoom-out').onclick = () => {
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      const cx = displayWidth / 2;
      const cy = displayHeight / 2;
      const old = scale;
      scale = Math.max(minScale, scale * 0.7);
      offsetX = cx - (cx - offsetX) * (scale / old);
      offsetY = cy - (cy - offsetY) * (scale / old);
      draw();
    };
    
    document.getElementById('reset').onclick = () => {
      popup.classList.remove('show');
      selectedLocation = null;
      document.querySelectorAll('.location-card').forEach(el => el.classList.remove('active'));
      closeSidebar();
      
      const displayWidth = canvas.width / (window.devicePixelRatio || 1);
      const displayHeight = canvas.height / (window.devicePixelRatio || 1);
      const targetScale = minScale;
      const displayW = COORD_W * targetScale;
      const displayH = COORD_H * targetScale;
      
      const targetX = (displayWidth - displayW) / 2;
      const targetY = (displayHeight - displayH) / 2;
      
      animateZoom(targetX, targetY, targetScale);
    };

    
    window.addEventListener('resize', resizeCanvas);
  </script>
</body>
</html>
